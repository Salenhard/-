# Перечисляемые типы

Перечисление (или «перечисляемый тип») — это тип данных, где любое значение (или «перечислитель») определяется как символьная константа. Объявить перечисление можно с помощью ключевого слова enum. Например:

// Объявляем новое перечисление Colors
```C++
enum Colors
{
    // Ниже находятся перечислители - все возможные значения этого типа данных.
    // Каждый перечислитель отделяется запятой (НЕ точкой с запятой)
    COLOR_RED,
    COLOR_BROWN,
    COLOR_GRAY,
    COLOR_WHITE,
    COLOR_PINK,
    COLOR_ORANGE,
    COLOR_BLUE,
    COLOR_PURPLE, // о конечной запятой читайте ниже

}; // однако сам enum должен заканчиваться точкой с запятой

// Определяем несколько переменных перечисляемого типа Colors
Colors paint = COLOR_RED;
Colors house(COLOR_GRAY);

// Объявляем новое перечисление Colors
enum Colors
{
    // Ниже находятся перечислители - все возможные значения этого типа данных.
    // Каждый перечислитель отделяется запятой (НЕ точкой с запятой)
    COLOR_RED,
    COLOR_BROWN,
    COLOR_GRAY,
    COLOR_WHITE,
    COLOR_PINK,
    COLOR_ORANGE,
    COLOR_BLUE,
    COLOR_PURPLE, // о конечной запятой читайте ниже

}; // однако сам enum должен заканчиваться точкой с запятой

// Определяем несколько переменных перечисляемого типа Colors
Colors paint = COLOR_RED;
Colors house(COLOR_GRAY);
```
Объявление перечислений не требует выделения памяти. Только когда переменная перечисляемого типа определена (например, как переменная paint в примере, приведенном выше), только тогда выделяется память для этой переменной.

Обратите внимание, каждый перечислитель отделяется запятой, а само перечисление заканчивается точкой с запятой.

Примечание: До C++11, конечная запятая после последнего перечислителя (как после COLOR_PURPLE в примере, приведенном выше) не разрешается (хотя многие компиляторы её все равно принимают). Однако начиная с C++11 конечная запятая разрешена.


## Имена перечислений

Идентификаторы перечислений часто начинаются с заглавной буквы, а имена перечислителей вообще состоят только из заглавных букв. Поскольку перечислители вместе с перечислением находятся в едином пространстве имен, то имена перечислителей не могут повторяться в разных перечислениях:
```C++
enum Colors
{
	YELLOW,
	BLACK, // BLACK находится в глобальном пространстве имен
	PINK
};

enum Feelings
{
	SAD,
	ANGRY,
	BLACK // получим ошибку, так как BLACK уже используется в enum Colors
};
```
Распространено добавление названия перечисления в качестве префикса к перечислителям, например: ANIMAL_ или COLOR_, как для предотвращения конфликтов имен, так и в целях комментирования кода.

## Значения перечислителей

Каждому перечислителю автоматически присваивается целочисленное значение в зависимости от его позиции в списке перечисления. По умолчанию, первому перечислителю присваивается целое число 0, а каждому следующему — на единицу больше, чем предыдущему:
```c++
#include <iostream>

enum Colors
{
	COLOR_YELLOW, // присваивается 0
	COLOR_WHITE,  // присваивается 1
	COLOR_ORANGE, // присваивается 2
	COLOR_GREEN,  // присваивается 3
	COLOR_RED,    // присваивается 4
	COLOR_GRAY,   // присваивается 5
	COLOR_PURPLE, // присваивается 6
	COLOR_BROWN   // присваивается 7
};

int main()
{
	Colors paint(COLOR_RED);
	std::cout << paint;

	return 0;
}
```
Результат выполнения программы:

4

Можно и самому определять значения перечислителей. Они могут быть как положительными, так и отрицательными, или вообще иметь аналогичные другим перечислителям значения. Любые, не определенные вами перечислители, будут иметь значения на единицу больше, чем значения предыдущих перечислителей. Например:
```C++
// Определяем новый перечисляемый тип Animals
enum Animals
{
    ANIMAL_PIG = -4,
    ANIMAL_LION, // присваивается -3
    ANIMAL_CAT, // присваивается -2
    ANIMAL_HORSE = 6,
    ANIMAL_ZEBRA = 6, // имеет то же значение, что и ANIMAL_HORSE
    ANIMAL_COW // присваивается 7
};
```
Обратите внимание, ANIMAL_HORSE и ANIMAL_ZEBRA имеют одинаковые значения. Хотя C++ это не запрещает, присваивать одно значение нескольким перечислителям в одном перечислении не рекомендуется.

Совет: Не присваивайте свои значения перечислителям.

Правило: Не присваивайте одинаковые значения двум перечислителям в одном перечислении, если на это нет веской причины.

Обработка перечислений

Поскольку значениями перечислителей являются целые числа, то их можно присваивать целочисленным переменным, а также выводить в консоль (как переменные типа int):
```C++

#include <iostream>

// Определяем новый перечисляемый тип Animals
enum Animals
{
	ANIMAL_PIG = -4,
	ANIMAL_LION, // присваивается -3
	ANIMAL_CAT, // присваивается -2
	ANIMAL_HORSE = 6,
	ANIMAL_ZEBRA = 6, // имеет то же значение, что и ANIMAL_HORSE
	ANIMAL_COW // присваивается 7
};

int main()
{
	int mypet = ANIMAL_PIG;
	std::cout << ANIMAL_HORSE; // конвертируется в int, а затем выводится на экран

	return 0;
}
```
Результат выполнения программы:

6

Компилятор не будет неявно конвертировать целочисленное значение в значение перечислителя. Следующее вызовет ошибку компиляции:

Animals animal = 7; // приведет к ошибке компиляции
Тем не менее, вы можете сделать подобное с помощью оператора static_cast:

Colors color = static_cast<Colors>(5); // но делать так не рекомендуется
Компилятор также не позволит вам вводить перечислители через std::cin:
```C++
#include <iostream>

enum Colors
{
	COLOR_PURPLE, // присваивается 0
	COLOR_GRAY,   // присваивается 1
	COLOR_BLUE,   // присваивается 2
	COLOR_GREEN,  // присваивается 3
	COLOR_BROWN,  // присваивается 4
	COLOR_PINK,   // присваивается 5
	COLOR_YELLOW, // присваивается 6
	COLOR_MAGENTA // присваивается 7
};

int main()
{
	Colors color;
	std::cin >> color; // приведет к ошибке компиляции

	return 0;
}
```
Однако, вы можете ввести целое число, а затем использовать оператор static_cast, чтобы поместить целочисленное значение в перечисляемый тип:

```C++
int inputColor;
std::cin >> inputColor;

Colors color = static_cast<Colors>(inputColor);
```
Каждый перечисляемый тип считается отдельным типом. Следовательно, попытка присвоить перечислитель из одного перечисления перечислителю из другого — вызовет ошибку компиляции:

Animals animal = COLOR_BLUE; // приведет к ошибке компиляции

Как и в случае с константами, перечисления отображаются в отладчике, что делает их еще более полезными.

Вывод перечислителей
Попытка вывести перечисляемое значение с помощью std::cout приведет к выводу целочисленного значения самого перечислителя (т.е. его порядкового номера). Но как вывести значение перечислителя в виде текста? Один из способов — написать функцию с использованием стейтментов if:
```C++
enum Colors
{
    COLOR_PURPLE, // присваивается 0
    COLOR_GRAY,   // присваивается 1
    COLOR_BLUE,   // присваивается 2
    COLOR_GREEN,  // присваивается 3
    COLOR_BROWN,  // присваивается 4
    COLOR_PINK,   // присваивается 5
    COLOR_YELLOW, // присваивается 6
    COLOR_MAGENTA // присваивается 7
};

void printColor(Colors color)
{
    if (color == COLOR_PURPLE)
        std::cout << "Purple";
    else if (color == COLOR_GRAY)
        std::cout << "Gray";
    else if (color == COLOR_BLUE)
        std::cout << "Blue";
    else if (color == COLOR_GREEN)
        std::cout << "Green";
    else if (color == COLOR_BROWN)
        std::cout << "Brown";
    else if (color == COLOR_PINK)
        std::cout << "Pink";
    else if (color == COLOR_YELLOW)
        std::cout << "Yellow";
    else if (color == COLOR_MAGENTA)
        std::cout << "Magenta";
    else
        std::cout << "Who knows!";
}
```
## Выделение памяти для перечислений

Перечисляемые типы считаются частью семейства целочисленных типов, и компилятор сам определяет, сколько памяти выделять для переменных типа enum. По стандарту C++ размер перечисления должен быть достаточно большим, чтобы иметь возможность вместить все перечислители. Но чаще всего размеры переменных enum будут такими же, как и размеры обычных переменных типа int.

Поскольку компилятору нужно знать, сколько памяти выделять для перечисления, то использовать предварительное объявление с ним вы не сможете. Однако существует простой обходной путь. Поскольку определение перечисления само по себе не требует выделения памяти и, если перечисление необходимо использовать в нескольких файлах, его можно определить в заголовочном файле и подключать этот файл везде, где необходимо использовать перечисление.

Польза от перечислений
Перечисляемые типы невероятно полезны для документации кода и улучшения читабельности.

Например, функции часто возвращают целые числа обратно в caller в качестве кодов ошибок, если что-то пошло не так. Как правило, небольшие отрицательные числа используются для представления возможных кодов ошибок. Например:
```C++
int readFileContents()
{
    if (!openFile())
        return -1;
    if (!parseFile())
        return -2;
    if (!readFile())
        return -3;

    return 0; // если всё прошло успешно
}
Однако магические числа, как в вышеприведенном примере, не очень эффективное решение. Альтернатива — использовать перечисления:

enum ParseResult
{
    SUCCESS = 0,
    ERROR_OPENING_FILE = -1,
    ERROR_PARSING_FILE = -2,
    ERROR_READING_FILE = -3
};

ParseResult readFileContents()
{
    if (!openFile())
        return ERROR_OPENING_FILE;
    if (!parseFile())
        return ERROR_PARSING_FILE;
    if (!readfile())
        return ERROR_READING_FILE;

    return SUCCESS; // если всё прошло успешно
}
```
Это и читать легче, и понять проще. Кроме того, функция, которая вызывает другую функцию, может проверить возвращаемое значение на соответствующий перечислитель. Это лучше, нежели самому сравнивать возвращаемый результат с конкретными целочисленными значениями, чтобы понять какая именно ошибка произошла, не так ли? Например:
```C++
if (readFileContents() == SUCCESS)
    {
    // Делаем что-нибудь
    }
else
    {
    // Выводим сообщение об ошибке
    }

if (readFileContents() == SUCCESS)
    {
    // Делаем что-нибудь
    }
else
    {
    // Выводим сообщение об ошибке
    }
    ```
Перечисляемые типы лучше всего использовать при определении набора связанных идентификаторов. Например, предположим, что вы пишете игру, в которой игрок может иметь один предмет, но этот предмет может быть нескольких разных типов:
```C++
#include <iostream>
#include <string>

enum ItemType
{
    ITEMTYPE_GUN,
    ITEMTYPE_ARBALET,
    ITEMTYPE_SWORD
};

std::string getItemName(ItemType itemType)
{
    if (itemType == ITEMTYPE_GUN)
        return std::string("Gun");
    if (itemType == ITEMTYPE_ARBALET)
        return std::string("Arbalet");
    if (itemType == ITEMTYPE_SWORD)
        return std::string("Sword");
}

int main()
{
    // ItemType - это перечисляемый тип, который мы объявили выше.
    // itemType (с маленькой i) - это имя переменной, которую мы определяем ниже (типа ItemType).
    // ITEMTYPE_GUN - это значение перечислителя, которое мы присваиваем переменной itemType
    ItemType itemType(ITEMTYPE_GUN);

    std::cout << "You are carrying a " << getItemName(itemType) << "\n";

    return 0;
}

Или, если вы пишете функцию для сортировки группы значений:

enum SortType
{
    SORTTYPE_FORWARD,
    SORTTYPE_BACKWARDS
};

void sortData(SortType type)
{
    if (type == SORTTYPE_FORWARD)
        // Сортировка данных в одном порядке
    else if (type == SORTTYPE_BACKWARDS)
        // Сортировка данных в обратном порядке
}
```
Многие языки программирования используют перечисления для определения логических значений. По сути, логический тип данных — это простое перечисление всего лишь с двумя перечислителями: true и false! Однако в языке C++ значения true и false определены как ключевые слова вместо перечислителей.

Источник: https://ravesli.com/urok-58-perechisleniya-tip-enum/
