# Move
Функция std::move() — это стандартная библиотечная функция, которая конвертирует передаваемый аргумент в r-value. Мы можем передать l-value в функцию std::move(), и std::move() вернет нам ссылку r-value. 
***
Для работы с std::move() нужно подключить заголовочный файл utility.
***
Проще говоря, move передаёт память одного объекта другому.
***
Пример:
```c++
#include <iostream>
#include <string>
#include <utility>

template<class T>
void swap(T& x, T& y)
{
	T tmp{ std::move(x) }; // вызывает конструктор перемещения
	x = std::move(y); // вызывает оператор присваивания перемещением
	y = std::move(tmp); // вызывает оператор присваивания перемещением
}

int main()
{
	std::string x{ "Anton" };
	std::string y{ "Max" };

	std::cout << "x: " << x << '\n';
	std::cout << "y: " << y << '\n';

	swap(x, y);

	std::cout << "x: " << x << '\n';
	std::cout << "y: " << y << '\n';

	return 0;
}
```
Следовательно, результат выполнения программы:

x: Anton
y: Max
x: Max
y: Anton

Источник: https://ravesli.com/urok-192-std-move/ 
 
# Ссылки r-value
Ссылки r-value — это ссылки, которые инициализируются только значениями r-values. Хотя ссылка l-value создается с использованием одного амперсанда, ссылка r-value создается с использованием двойного амперсанда:
```c++
int x = 7;
	int& l_value = x; // инициализация ссылки l-value переменной x (значение l-value)
	int&& r_value = 7; // инициализация ссылки r-value литералом 7 (значение r-value)
//Ссылки r-value не могут быть инициализированы значениями l-values.
    int&& rref = 7; // поскольку мы инициализируем ссылку r-value литералом 7, то создается временный объект со значением 7, на который указывает ссылка r-value
    rref = 12;
    std::cout << rref;
```
Результат выполнения программы: 12.
***
Хотя это может показаться странным, но при инициализации ссылки r-value литералом, создается временный объект, на который ссылается ссылка r-value (она не ссылается на сам литерал).
***
Ссылки r-value чаще всего используются в качестве параметров функции. Это наиболее полезно при перегрузке функций, когда мы хотим, чтобы выполнение функции отличалось в зависимости от аргументов (l-values или r-values).

```c++
#include <iostream>

void fun(const int& lref) // перегрузка функции для работы с аргументами l-values
{
	std::cout << "l-value reference to const\n";
}

void fun(int&& rref) // перегрузка функции для работы с аргументами r-values
{
	std::cout << "r-value reference\n";
}

int main()
{
	int x = 7;
	fun(x); // аргумент l-value вызывает функцию с ссылкой l-value
	fun(7); // аргумент r-value вызывает функцию с ссылкой r-value

	return 0;
}
```
Результат выполнения программы:
•	l-value reference to const
•	r-value reference

Источник: https://ravesli.com/urok-190-ssylki-r-value/#toc-0 

