# Псевдонимы и определения типов (C++)

Объявление псевдонима можно использовать для объявления имени, которое будет использоваться в качестве синонима для ранее объявленного типа. (Этот механизм также называется псевдонимом типа). Этот механизм также можно использовать для создания шаблона псевдонима, который может быть особенно полезен для пользовательских распределителей.

## Синтаксис

```c++
using identifier = type;
```
## Примечания
**identifier**
Имя псевдонима.

**type**
Идентификатор типа, для которого создается псевдоним.

Псевдоним не вводит в программу новый тип и не может менять значение существующего имени типа.

Простейшая форма псевдонима эквивалентна **typedef** механизму из c++ 03:

```c++
// C++11
using counter = long;

// C++03 equivalent:
// typedef long counter;
```
Оба этих механизма позволяют создавать переменные типа "счетчик". Псевдоним типа для std::ios_base::fmtflags, приведенный в следующем примере, может быть более полезен.

```c++
// C++11
using fmtfl = std::ios_base::fmtflags;

// C++03 equivalent:
// typedef std::ios_base::fmtflags fmtfl;

fmtfl fl_orig = std::cout.flags();
fmtfl fl_hex = (fl_orig & ~std::cout.basefield) | std::cout.showbase | std::cout.hex;
// ...
std::cout.flags(fl_hex);
```
Псевдонимы также работают с указателями на функции, но гораздо удобнее для чтения, чем эквивалентное определение типа:

```c++
// C++11
using func = void(*)(int);

// C++03 equivalent:
// typedef void (*func)(int);

// func can be assigned to a function pointer value
void actual_function(int arg) { /* some code */ }
func fptr = &actual_function;
```
Ограничением typedef механизма является то, что оно не работает с шаблонами. Напротив, синтаксис псевдонима типа в C ++11 позволяет создавать шаблоны псевдонимов:

```c++
template<typename T> using ptr = T*;

// the name 'ptr<T>' is now an alias for pointer to T
ptr<int> ptr_int;
```

## Определения типов
**typedef**   Объявление вводит имя, которое в пределах его области видимости преобразуется в синоним для типа, заданного в объявлении **typedef** .

Объявления **typedef** можно использовать для создания более коротких или более понятных имен для типов, уже определенных в языке или объявленных пользователем. Имена typedef позволяют инкапсулировать детали реализации, которые могут измениться.

В отличие от **class** объявлений, **struct** , **union** и **enum** , **typedef** объявления не предоставляют новые типы — они представляют новые имена для существующих типов.

Имена, объявленные с помощью **typedef** , занимают то же пространство имен, что и другие идентификаторы (кроме меток операторов). Таким образом, в них не может использоваться тот же идентификатор, что и в объявленном ранее имени, за исключением случаев, когда они находятся в объявлении типа класса. Рассмотрим следующий пример.

```c++
// typedef_names1.cpp
// C2377 expected
typedef unsigned long UL;   // Declare a typedef name, UL.
int UL;                     // C2377: redefined.
```
Правила скрытия имен, относящиеся к другим идентификаторам, также управляют видимостью имен, объявленных с помощью **typedef** . Поэтому следующий код допустим в C++:

```c++
// typedef_names2.cpp
typedef unsigned long UL;   // Declare a typedef name, UL
int main()
{
   unsigned int UL;   // Redeclaration hides typedef name
}
// typedef UL back in scope
```
```c++
// typedef_specifier1.cpp
typedef char FlagType;

int main()
{
}

void myproc( int )
{
    int FlagType;
}
```
При объявлении в локальной области идентификатора с тем же именем, что и имя **typedef**, или при объявлении члена структуры либо объединения в той же области или во внутренней области обязательно должен указываться спецификатор типа. Пример:

```c++
typedef char FlagType;
const FlagType x;
```
Чтобы повторно использовать имя **FlagType** для идентификатора, члена структуры или члена объединения, необходимо указать тип:

```c++
const int FlagType;  // Type specifier require
```
Недостаточно написать

```c++
const FlagType;      // Incomplete specification
```
поскольку FlagType воспринимается как часть типа, а не как заново объявляемый идентификатор. Это объявление недопустимо, как и

```c++
int;  // Illegal declaration
```
С помощью **typedef** можно объявить любой тип, включая типы указателей, функций и массивов. Имя **typedef** для типа указателя на структуру или объединение можно объявить до определения типа структуры или объединения, если только определение находится в той же области видимости, что и объявление.


