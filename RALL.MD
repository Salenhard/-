#RAII
Идиома RAII “Resource Acquisition is Initialization” — захват ресурса есть инициализация. Объекты владеют ресурсами.
Современный C ++ избегает использования памяти кучи в максимально возможной степени, объявляя объекты в стеке. Когда ресурс слишком велик для стека, он должен принадлежать объекту. Когда объект инициализируется, он получает ресурс, которым он владеет. Затем объект отвечает за освобождение ресурса в его деструкторе. Сам объект-владелец объявляется в стеке. 
Например, у нас есть класс для работы с динамическим массивом, то есть ресурсом объекта будет являться память. При инициализации объекта в конструкторе (или определённом методе) должна будет выделиться память под массив. После всех действий с этим объектом, когда он наконец выйдет из области видимости, должен будет вызваться деструктор, в котором освободится вся память, используемая этим объектом.
Пример:
```C++
class arrays {
    int n;
    int* arr;
    
public:

    arrays(int _n) {
        n = _n;
        arr = new int[n];
    }

    void in_random() {
        for (int i = 0; i < n; i++)
            arr[i] = rand() % 10 + 1;
    }

    void print_cons() {
        for (int i = 0; i < n; i++)
            cout << arr[i] << " ";
    }

    ~arrays() {
        delete[]arr;
    }

};
```
С++ не поддерживает блоки "finally". Причина в том, что С++ вместо этого поддерживает RAII.
Источники: 
Про RAII - https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-160 
Про finally - https://qastack.ru/software/197562/why-is-there-no-finally-construct-in-c
https://utyatnishna.ru/info/16946/does-c-support-finally-blocks-and-whats-this-raii-i-keep-hearing-about 
