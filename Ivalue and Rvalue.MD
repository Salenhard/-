#lvalue and Rvalue
**lvalue** (locator value) представляет собой объект, который занимает идентифицируемое место в памяти (например, имеет адрес).
int x;
	x = 4;
Оператор присваивания ожидает lvalue с левой стороны, и x является lvalue, потому что это объект с идентифицируемым местом в памяти. 
Константы, выражения (например, x+1, x*2и т.п.), функции не являются lvalue, что автоматически делает их rvalue.
**rvalue** — это выражение, которое не представляет собой объект, который занимает идентифицируемое место в памяти.
Однако функции, возвращающие ссылку или указатель, являются lvalue:
```c++
int globalvar = 20;

int& foo()
{
    return globalvar;
}

int main()
{
    foo() = 10;
    cout << globalvar;
    return 0;
}
```
```c++
int globalvar = 20;

int* foo()
{
    return &globalvar;
}

int main()
{
    *foo() = 10;
    cout << globalvar;
    return 0;
} 
```
Константные переменные также являются lvalue:
const int a = 10; // 'a' - lvalue
a = 10;           // но ему не может быть присвоено значение!
Все lvalue, которые не являются массивом, функцией и не имеют неполный тип, могут быть преобразованы (неявно) в rvalue.
Можно ли неявно преобразовать rvalue в lvalue? Нет! (Отсутствие неявного преобразования означает, что rvalue не могут быть использованы там, где ожидается lvalue). Однако это возможно при явном преобразовании, например, унарный оператор '*' (разыменование) принимает rvalue в качестве аргумента, но возвращает lvalue в качестве результата.:
```c++ 
int arr[] = { 1, 2 };
int* p = &arr[0];
*(p + 1) = 10;   // p + 1 rvalue, однако *(p + 1) уже lvalue
```
Источник: https://habr.com/ru/post/348198/ 
